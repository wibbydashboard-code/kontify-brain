VELOX: Manual Maestro de IngenierÃ­a AgÃ©ntica (Gemini Edition)

VersiÃ³n: 7.0 (Full Gemini Integration)
Stack: Next.js 16 (TS) + Supabase + Gemini 1.5 (Type-Safe) + Vercel
MetodologÃ­a: Bucle AgÃ©ntico (Delimitar â†’ Deconstruir â†’ Ejecutar â†’ Validar)

Este documento es la Fuente de Verdad Ãšnica. Sigue las fases estrictamente.

ğŸ—ï¸ Fase 0: La ConstituciÃ³n del Proyecto (Contexto Gemini)

Antes de escribir cÃ³digo, definimos las "Leyes de la RobÃ³tica" para que Gemini entienda tu proyecto.

1. DefiniciÃ³n de Reglas (GEMINI.md)

Crea este archivo en la raÃ­z. Este serÃ¡ el "cerebro" compartido del proyecto.

# VELOX Project Rules (Gemini Protocol)

## 1. Tech Stack (Strict Types)
- **Frontend**: Next.js 16 (App Router), Tailwind CSS, Shadcn/UI, Lucide React.
- **Backend**: Server Actions (Next.js), Zod Validation (OBLIGATORIO).
- **Data**: Supabase (PostgreSQL + RLS).
- **AI Engine**: Google Generative AI (via Vercel AI SDK) + Zod Structured Output.
- **Testing**: Vitest + React Testing Library.

## 2. Agentic Workflow (The Loop)
Todo cambio sigue el protocolo de IngenierÃ­a AgÃ©ntica:
1. **Delimitar**: Definir quÃ© es "Ã©xito" (Success Criteria).
2. **IngenierÃ­a Inversa**: Desglosar dependencias antes de codificar.
3. **Planificar**: Generar PRP detallado (ver `templates/prp_base.md`).
4. **Ejecutar**: Iterar tarea por tarea.
5. **Validar**: Niveles 1-4 (Lint -> Unit -> Integration -> E2E).

## 3. Code Standards & Gotchas
- **Feature-First**: Estructura `src/features/[feature]/`.
- **Type-Safe AI**: NUNCA usar texto libre. La IA debe retornar JSON validado por Zod (`generateObject`).
- **Supabase**: RLS debe estar activo. Usar `@supabase/ssr` para cookies.
- **Testing**: No se aceptan Pull Requests sin tests unitarios.


2. Setup de Herramientas (Gemini Native)

Instalamos las dependencias para replicar la seguridad de tipos ("SKILL") en TypeScript:

# Core & Data
npm install @supabase/ssr @supabase/supabase-js zod lucide-react clsx tailwind-merge

# AI Type-Safety (Gemini + Zod)
npm install ai @ai-sdk/google zsa # zsa = Zod Server Actions (tipado estricto)

# Testing (Niveles 2-3 de validaciÃ³n)
npm install -D vitest @testing-library/react @vitejs/plugin-react jsdom


ğŸ”„ El Bucle AgÃ©ntico (EjecuciÃ³n por MÃ³dulo)

Usa estos prompts exactos con Gemini para construir cada parte del sistema.

ğŸšš Fase 1: Datos y Flota (Database Layer)

Aplicando el Bucle AgÃ©ntico al nÃºcleo.

Prompt para Gemini:

"Activa el modo Arquitecto de Datos.
Objetivo: Definir esquema SQL robusto en supabase/migrations para el mÃ³dulo Fleet.
Base: Usa el template prp_base.md.
Tablas: companies, units, contracts, maintenance_logs.
Requerimiento CrÃ­tico: Incluir polÃ­ticas RLS (Row Level Security).
Niveles de ValidaciÃ³n:

Nivel 1: Sintaxis SQL vÃ¡lida.

Nivel 3: Script SQL de prueba que inserte una unidad y verifique que existe."

ğŸ§  Fase 2: Motor de IA AgÃ©ntico (Type-Safe Agents)

AquÃ­ adaptamos el concepto de "Agentes Pydantic" a TypeScript + Zod. Esto evita que la IA "alucine" respuestas.

Prompt para Gemini:

"Activa el modo AI Engineer.
Objetivo: Crear el motor de IA en src/features/ai usando @ai-sdk/google.
PatrÃ³n: Type-Safe Agents (Gemini + Zod).
Blueprint:

Crear src/features/ai/gemini-client.ts.

Implementar funciÃ³n generateObject (SDK Vercel AI) usando el modelo gemini-1.5-flash.

Definir Agentes (Herramientas):

RiskAnalyst: Input: Unit[]. Output: z.object({ riskLevel: z.enum(['Low','High']), reasoning: z.string() }).

ContractExtractor: Input: string (OCR). Output: ContractSchema.

MechanicExpert: Input: symptom. Output: DiagnosisSchema.
ValidaciÃ³n Nivel 2: Tests unitarios con Vitest que simulen respuestas JSON malformadas y aseguren que Zod las rechaza."

âœ¨ Fase 3: IntegraciÃ³n UX (Interface Layer)

Conectamos los agentes seguros a la interfaz visual.

Prompt para Gemini:

"Activa el modo Frontend Expert.
Objetivo: UI de GestiÃ³n de Flotas y Contratos.
Blueprint:

UnitTable: Implementar con TanStack Table y filtros por columnas.

ContractUpload: Modal que invoca al ContractExtractor Agent.

Flujo: Subir -> Server Action (Gemini) -> Rellenar Formulario -> Guardar en Supabase.
ValidaciÃ³n Nivel 3: Test de integraciÃ³n simulando el flujo de 'Crear Unidad' completo."

ğŸ›¡ï¸ Fase 4: ValidaciÃ³n y Cierre (Quality Gate)

Este paso es obligatorio antes de cerrar cualquier tarea. Gemini actuarÃ¡ como QA.

Prompt para Gemini:

"Activa el modo QA Specialist.
Target: Todo el proyecto VELOX.

Ejecuta Nivel 1: npm run type-check (0 errores permitidos).

Ejecuta Nivel 2: npm run test (Vitest).

Revisa supabase/migrations buscando tablas sin RLS.

Si todo pasa en verde, genera el reporte de entrega."

ğŸš€ GuÃ­a de Inicio RÃ¡pido

Contexto: Crea GEMINI.md en la raÃ­z con las reglas de arriba.

InstalaciÃ³n: Copia y pega el bloque de npm install.

EjecuciÃ³n: Copia el primer Prompt de la Fase 1 y pÃ©galo en el chat.

Â¡EstÃ¡s listo para construir VELOX con arquitectura Enterprise y cero deuda tÃ©cnica!