GUÃA MAESTRA: PROYECTO VELOX (Antigravity Protocol v3.0)

Esta guÃ­a contiene la secuencia exacta de prompts para construir VELOX (GestiÃ³n de Flota con IA) utilizando Next.js 16, Supabase, Vercel y Gemini AI.

InstrucciÃ³n para el Usuario: Copia y pega estos prompts en orden. No avances de fase hasta completar la anterior.

ğŸ“‹ Fase 1: Cimientos, Base de Datos y Tipos

Objetivo: Establecer la infraestructura "Database-First" y la seguridad RLS.

ğŸ‘‰ Prompt 1: InicializaciÃ³n y Schema SQL

"ActÃºa como Arquitecto Senior de Software (Protocolo Antigravity). Vamos a iniciar el proyecto VELOX.

1. Stack TecnolÃ³gico:

Framework: Next.js 16 (App Router) + TypeScript.

DB: Supabase (PostgreSQL).

UI: Tailwind CSS + shadcn/ui + Lucide React.

Deploy: Vercel.

2. Estructura de Carpetas (Feature-First):
Genera los comandos de terminal para esta estructura:
src/
â”œâ”€â”€ app/
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ dashboard/       # KPIs y GrÃ¡ficas
â”‚   â”œâ”€â”€ fleet/           # Unidades (CRUD)
â”‚   â”œâ”€â”€ contracts/       # Contratos y Pagos
â”‚   â”œâ”€â”€ maintenance/     # Taller y DiagnÃ³stico IA
â”‚   â””â”€â”€ ai/              # Acciones de Gemini
â””â”€â”€ shared/              # components/ui, lib/supabase, types

3. DefiniciÃ³n de Base de Datos (SQL Robusto):
Genera un archivo supabase/migrations/0001_initial_schema.sql con estas tablas (usa UUIDs y Foreign Keys):

companies: id, name (Ej: Icold, Intra), rfc.

units: id, company_id (FK), economic_number (Ej: I262), plate, type (Tracto, Caja, Utilitario), brand, status (Active, Maintenance, Down), image_url.

contracts: id, unit_id (FK), provider_name (Ej: Paccar), contract_number, start_date, end_date, monthly_cost, type (Leasing, Insurance), doc_url.

payments: id, contract_id (FK), amount, due_date, status (Pending, Paid, Overdue), invoice_url.

4. Seguridad:
Incluye en el SQL la activaciÃ³n de RLS (ALTER TABLE... ENABLE ROW LEVEL SECURITY) y polÃ­ticas bÃ¡sicas de lectura/escritura pÃºblica para desarrollo."

ğŸ¨ Fase 2: DiseÃ±o AtÃ³mico y Layout

Objetivo: Replicar el diseÃ±o visual de index_flota (2).html usando componentes modernos.

ğŸ‘‰ Prompt 2: Sistema de DiseÃ±o y Layout

"Tengo un diseÃ±o aprobado estilo 'Enterprise Dark' (Slate-800 sidebar, Slate-50 background).

1. ConfiguraciÃ³n de UI:
Instruye cÃ³mo instalar shadcn/ui y los componentes base: button, card, dialog, table, badge, progress, sheet.

2. Componentes Estructurales:
Genera el cÃ³digo para:

src/shared/components/Sidebar.tsx: Fondo bg-slate-800. Links para Dashboard, Unidades, Contratos. Usa usePathname para resaltar el activo en bg-slate-700.

src/shared/components/Header.tsx: Blanco, sombra suave, breadcrumbs y botÃ³n de usuario.

src/app/layout.tsx: Integra Sidebar (fijo izquierda) y Header (scrollable derecha).

3. TipografÃ­a:
Configura next/font con la familia 'Inter' para todo el body."

ğŸšš Fase 3: LÃ³gica de Negocio y Server Actions

Objetivo: Conectar la UI con Supabase usando Server Actions seguras y Zod.

ğŸ‘‰ Prompt 3: Dashboard y GestiÃ³n de Flota

"Implementemos la lÃ³gica 'Backend-for-Frontend' con Server Actions.

1. Feature: Dashboard (src/features/dashboard)

Crea actions/get-dashboard-metrics.ts: Consulta a Supabase para contar:

Total Unidades.

Contratos Activos.

Pagos Vencidos (Join con tabla payments donde status='Overdue').

Pagos PrÃ³ximos (30 dÃ­as).

Crea components/KPIGrid.tsx: Visualiza los 4 nÃºmeros en tarjetas (replica el HTML original).

2. Feature: Unidades (src/features/fleet)

Crea actions/get-units.ts: Debe aceptar parÃ¡metros de filtro (company_id, status) y paginaciÃ³n.

Crea components/UnitTable.tsx: Usa TanStack Table (o tabla simple de shadcn).

Columnas: EconÃ³mico, Placa, Tipo, Empresa, Badge de Estatus.

AcciÃ³n: BotÃ³n 'Ver Detalles' que abre un Sheet/Modal.

Nota: Usa Zod para validar cualquier input en las Server Actions."

ğŸ§  Fase 4: Inteligencia Artificial (Backend Gemini)

Objetivo: Crear las "neuronas" que procesan datos complejos.

ğŸ‘‰ Prompt 4: Motor de IA (Gemini)

"Configura el cerebro de VELOX. Usa el SDK google-generative-ai.

Crea src/features/ai/actions/gemini.ts con estas 3 funciones exportadas:

analyzeFleetRisks(units: Unit[]):

Prompt: 'Analiza este JSON de unidades. Identifica patrones de riesgo (ej: muchos camiones viejos en una sola empresa) y suguiere rotaciÃ³n. Retorna JSON: { summary, critical_risks[], savings_opportunities[] }'.

extractContractData(ocrText: string):

Prompt: 'Eres un abogado experto. Extrae de este texto de contrato: proveedor, fechas, costo mensual y tipo. Retorna JSON exacto para insertar en DB'.

predictMaintenance(symptoms: string, vehicleModel: string):

Prompt: 'ActÃºa como MecÃ¡nico Jefe. Para este sÃ­ntoma en este modelo, dame: Causas probables (con % probabilidad), Severidad (Alta/Media/Baja) y AcciÃ³n recomendada'.

Requisito: Configura la respuesta de Gemini para que sea responseMimeType: 'application/json'."

âœ¨ Fase 5: IntegraciÃ³n Final (UI + IA)

Objetivo: Conectar los "Botones MÃ¡gicos" en la interfaz.

ğŸ‘‰ Prompt 5: Experiencia de Usuario IA

"Vamos a hacer la UI inteligente.

1. Modal de AnÃ¡lisis de Contratos (src/features/contracts)

Crea un componente ContractUploadModal.

Flujo: El usuario pega texto (o simula subida OCR).

Al hacer click en 'Analizar con IA', llama a extractContractData.

Rellena automÃ¡ticamente los inputs del formulario con la respuesta.

2. Asistente de Taller (src/features/maintenance)

Crea un formulario donde el mecÃ¡nico describe 'Ruido en frenos'.

Muestra una tarjeta de 'DiagnÃ³stico VELOX' con la respuesta de predictMaintenance, usando colores de semÃ¡foro para la severidad.

3. Pulido Final:

AÃ±ade 'Skeletons' de carga para las llamadas a la IA.

Usa sonner para mostrar notificaciones Toast de Ã©xito/error."